<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>ContentFilters</key>
	<dict/>
	<key>auto_connect</key>
	<true/>
	<key>data</key>
	<dict>
		<key>connection</key>
		<dict>
			<key>database</key>
			<string>munch</string>
			<key>host</key>
			<string>130.211.79.11</string>
			<key>kcid</key>
			<string>2625964635589739391</string>
			<key>name</key>
			<string>kato</string>
			<key>rdbms_type</key>
			<string>mysql</string>
			<key>sslCACertFileLocation</key>
			<string></string>
			<key>sslCACertFileLocationEnabled</key>
			<integer>0</integer>
			<key>sslCertificateFileLocation</key>
			<string></string>
			<key>sslCertificateFileLocationEnabled</key>
			<integer>0</integer>
			<key>sslKeyFileLocation</key>
			<string></string>
			<key>sslKeyFileLocationEnabled</key>
			<integer>0</integer>
			<key>type</key>
			<string>SPTCPIPConnection</string>
			<key>useSSL</key>
			<integer>0</integer>
			<key>user</key>
			<string>root</string>
		</dict>
		<key>session</key>
		<dict>
			<key>connectionEncoding</key>
			<string>latin1</string>
			<key>contentFilter</key>
			<dict/>
			<key>contentPageNumber</key>
			<integer>1</integer>
			<key>contentSelection</key>
			<data>
			YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFy
			Y2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJX
			TlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAF
			gAdUdHlwZVRyb3dzXxAdU2VsZWN0aW9uRGV0YWlsVHlwZU5TSW5k
			ZXhTZXTSFwsYGVxOU1JhbmdlQ291bnQQAIAG0hscHR5aJGNsYXNz
			bmFtZVgkY2xhc3Nlc1pOU0luZGV4U2V0oh8gWk5TSW5kZXhTZXRY
			TlNPYmplY3TSGxwiI1xOU0RpY3Rpb25hcnmiIiBfEA9OU0tleWVk
			QXJjaGl2ZXLRJidUZGF0YYABAAgAEQAaACMALQAyADcAQABGAE0A
			VQBgAGcAagBsAG4AcQBzAHUAdwB8AIEAoQCmALMAtQC3ALwAxwDQ
			ANsA3gDpAPIA9wEEAQcBGQEcASEAAAAAAAACAQAAAAAAAAAoAAAA
			AAAAAAAAAAAAAAABIw==
			</data>
			<key>contentSortColIsAsc</key>
			<true/>
			<key>contentViewport</key>
			<string>{{0, 1406}, {949, 662}}</string>
			<key>isToolbarVisible</key>
			<true/>
			<key>queries</key>
			<string>

DROP FUNCTION IF EXISTS initial_volume;
DELIMITER $$
CREATE FUNCTION initial_volume(date DATE, symbol TEXT)
	RETURNS DOUBLE
	LANGUAGE SQL 
	READS SQL DATA
BEGIN
	DECLARE A INT;

	SELECT SUM(quotes.open * quotes.volume) FROM quotes 
		WHERE (quotes.time BETWEEN '09:30' AND '09:35') AND quotes.date = date AND quotes.symbol = symbol INTO A;

	RETURN A / 5;
END;
$$
DELIMITER ;




DROP FUNCTION IF EXISTS buy_price;
DELIMITER $$
CREATE FUNCTION buy_price(date DATE, symbol TEXT)
	RETURNS DOUBLE
	LANGUAGE SQL 
	READS SQL DATA
BEGIN
	DECLARE A DOUBLE;

	SELECT quotes.open FROM quotes 
		WHERE quotes.date = date AND (quotes.time BETWEEN '09:45' AND '09:50') AND quotes.symbol = symbol
		ORDER BY quotes.time LIMIT 1 INTO A;

	RETURN A;
END;
$$
DELIMITER ;

DROP FUNCTION IF EXISTS sell_price;
DELIMITER $$
CREATE FUNCTION sell_price(DATE DATE, symbol TEXT)
	RETURNS DOUBLE
	LANGUAGE SQL 
	READS SQL DATA
BEGIN
	DECLARE A DOUBLE;

	SELECT quotes.open FROM quotes 
		WHERE quotes.date = DATE AND (quotes.time BETWEEN '15:45' AND '16:00') AND quotes.symbol = symbol
		ORDER BY quotes.time LIMIT 1 INTO A;

	RETURN A;
END;
$$
DELIMITER ;

DROP FUNCTION IF EXISTS profit;
DELIMITER $$
CREATE FUNCTION profit(DATE DATE, symbol TEXT)
	RETURNS DOUBLE
	LANGUAGE SQL 
	READS SQL DATA
BEGIN
	DECLARE A DOUBLE;
	DECLARE B DOUBLE;

	SELECT buy_price(DATE, symbol) INTO A;
	SELECT sell_price(DATE, symbol) INTO B;
	
	RETURN 100*((B-A) / A);
END;
$$
DELIMITER ;



DROP FUNCTION IF EXISTS daily_change;
DELIMITER $$
CREATE FUNCTION daily_change(DATE DATE, symbol TEXT)
	RETURNS DOUBLE
	LANGUAGE SQL 
	READS SQL DATA
BEGIN
	DECLARE A DOUBLE;
	DECLARE B DOUBLE;

	SELECT quotes.open FROM quotes 
		WHERE quotes.date = date AND quotes.symbol = symbol
		ORDER BY quotes.time LIMIT 1 INTO A;

	SELECT quotes.open FROM quotes 
		WHERE quotes.date = DATE AND quotes.symbol = symbol
		ORDER BY quotes.time DESC LIMIT 1 INTO B;
	
	RETURN 100*((B-A) / A);
END;
$$
DELIMITER ;









DROP FUNCTION IF EXISTS momentum;
DELIMITER $$
CREATE FUNCTION momentum(DATE DATE, symbol TEXT)
	RETURNS DOUBLE
	LANGUAGE SQL
	READS SQL DATA
BEGIN
	DECLARE A DOUBLE;
	DECLARE B DOUBLE;
	DECLARE C DOUBLE;

	SELECT quotes.open FROM quotes 
		WHERE (quotes.time between '09:30' AND '09:45')
		AND quotes.date = DATE AND quotes.symbol = symbol
		ORDER by quotes.time ASC LIMIT 1 INTO A;

	SELECT quotes.open FROM quotes 
		WHERE (quotes.time BETWEEN '09:30' AND '09:45')
		AND quotes.date = DATE AND quotes.symbol = symbol
		ORDER BY quotes.time DESC LIMIT 1 INTO B;

--	SELECT SUM(quotes.open * quotes.volume) / 15 FROM quotes 
--		WHERE (quotes.time BETWEEN '09:30' AND '09:45') AND quotes.date = date AND quotes.symbol = symbol INTO C;

--	IF C &gt; 10000 THEN
--		RETURN 100*((B-A) / A);
--	ELSE
--		RETURN -99;
--	END IF;
	
	RETURN 100*((B-A) / A);
END;
$$
DELIMITER ;

DROP FUNCTION IF EXISTS find_best_sector;
DELIMITER $$
CREATE FUNCTION find_best_sector(DATE DATE)
	RETURNS TEXT
	READS SQL DATA
BEGIN
	DECLARE A TEXT;

	SELECT sector FROM stocks 
		WHERE initial_volume(date, symbol) &gt; 10000
		GROUP BY sector
		HAVING AVG(momentum(DATE, symbol)) &gt; 0
		ORDER BY AVG(momentum(DATE, symbol)) DESC LIMIT 1 INTO A;
	
	RETURN A;
END;
$$
DELIMITER ;



DROP PROCEDURE IF EXISTS run;
DELIMITER $$
CREATE PROCEDURE run(date DATE)
	LANGUAGE SQL -- This element is optional and will be omitted from subsequent examples
	READS SQL DATA
BEGIN
	DECLARE sector TEXT;

	SELECT find_best_sector(date) INTO sector;

	SELECT sector, symbol, ROUND(momentum(date, symbol),1) AS momentum, buy_price(date, symbol) AS buy, sell_price(date, symbol) AS sell , ROUND(profit(date, symbol), 1) AS `our profit (%)`, 	ROUND(daily_change(date, symbol),1) AS `daily change (%)`  FROM stocks  
			WHERE initial_volume(date, symbol) &gt; 100000 AND stocks.sector=sector ORDER BY momentum DESC LIMIT 5;

END;
$$
DELIMITER ;






DROP FUNCTION IF EXISTS simulate;
DELIMITER $$
CREATE FUNCTION simulate(date DATE)
	RETURNS DOUBLE
	READS SQL DATA
BEGIN
	DECLARE A DOUBLE;
	DECLARE sector TEXT;

	SELECT find_best_sector(date) INTO sector;

	SELECT AVG(profit) FROM 
(
	SELECT sector, symbol, ROUND(momentum(date, symbol),1) AS momentum, buy_price(date, symbol) AS buy, sell_price(date, symbol) AS sell , ROUND(profit(date, symbol), 1) AS `profit`, 	ROUND(daily_change(date, symbol),1) AS `daily change (%)`  FROM stocks  
		WHERE initial_volume(date, symbol) &gt; 100000 AND stocks.sector=sector ORDER BY momentum DESC LIMIT 5

) AS T INTO A;
	

	RETURN A;
END;
$$
DELIMITER ;


select * from quotes where symbol = 'SEMG' and date = '2016-05-31';

select distinct date, symbol from quotes;

call run('2016-05-31');
select run('2016-06-01');
select simulate('2016-06-08');

create or replace view foo as
select distinct date, symbol from quotes

select * from foo where date='2016-+6-01' and symbol='A'
create or replace view foo as
select distinct date, symbol, momentum(date, symbol) from quotes where date='2016-06-01' and symbol='A'

select date, ROUND(simulate(date),1) from dates ;
where date&gt;='2016-09-01';

select * from foo where date='2016-06-01';

select downloaded from stocks order by downloaded desc limit 1
select downloaded from stocks order by downloaded asc limit 1
 
select * from foo limit 1;

select * from foo where date='2016-05-25';

select * from (run('2016-05-31'));

select '2016-05-25', simulate('2016-05-25'); 

</string>
			<key>table</key>
			<string>dates</string>
			<key>view</key>
			<string>SP_VIEW_CUSTOMQUERY</string>
			<key>windowVerticalDividerPosition</key>
			<real>200</real>
		</dict>
	</dict>
	<key>encrypted</key>
	<false/>
	<key>format</key>
	<string>connection</string>
	<key>queryFavorites</key>
	<array/>
	<key>queryHistory</key>
	<array>
		<string>select date, count(symbol) from quotes group by date</string>
		<string>select count(symbol) from stocks</string>
		<string>select count(date) from quotes</string>
		<string>RELOAD PRIVILEGES</string>
		<string>FLUSH PRIVILEGES</string>
		<string>select @buyTime</string>
		<string>DROP FUNCTION IF EXISTS hello_world;
CREATE FUNCTION hello_world()
	RETURNS INT
	LANGUAGE SQL -- This element is optional and will be omitted from subsequent examples
	READS SQL DATA
BEGIN
  RETURN 1;
END;</string>
		<string>DROP FUNCTION IF EXISTS hello_world;
CREATE FUNCTION hello_world()
  RETURNS INT
  LANGUAGE SQL -- This element is optional and will be omitted from subsequent examples
BEGIN
  RETURN 1;
END;</string>
		<string>DROP FUNCTION IF EXISTS hello_world;
CREATE FUNCTION hello_world(addressee TEXT)
  RETURNS TEXT
  LANGUAGE SQL -- This element is optional and will be omitted from subsequent examples
BEGIN
  RETURN CONCAT('Hello ', addressee);
END;</string>
		<string>CREATE FUNCTION F_TEST(PID INT) RETURNS VARCHAR
READS SQL DATA
BEGIN
	select 1</string>
		<string>CREATE FUNCTION F_TEST(PID INT) RETURNS VARCHAR
READS SQL DATA
BEGIN
  DECLARE NAME_FOUND VARCHAR DEFAULT ""</string>
		<string>DROP FUNCTION IF EXISTS F_TEST</string>
		<string>DROP FUNCTION IF EXISTS F_TEST //</string>
		<string>select open from quotes 
where (time between  '09:30' and '09:35') 
and date='2016-08-19' and symbol = 'A'
order by time limit 1</string>
		<string>@a = select open from quotes 
where (time between  '09:30' and '09:35') 
and date='2016-08-19' and symbol = 'A'
order by time limit 1</string>
		<string>select open from quotes 
where (time between  '10:00' and '10:05') 
and date='2016-08-19' and symbol = 'A'
order by time limit 1</string>
		<string>select open from quotes 

where (time between  '09:30' and '09:35') 
and date='2016-08-19' and symbol = 'A'
order by time limit 1</string>
		<string>select * from quotes 

where 
 (time between  '09:30' and '09:35') 
and
date='2016-08-19' and symbol = 'A'
order by time limit 1</string>
		<string>BEGIN
select * from quotes 

where 
 (time between  '09:30' and '09:35') 
and
date='2016-08-19' and symbol = 'A'
order by time limit 1</string>
		<string>select * from quotes 

where 
 (time between  '09:30' and '09:45') 
and
date='2016-08-19' and symbol = 'A'
order by time limit 1</string>
	</array>
	<key>rdbms_type</key>
	<string>mysql</string>
	<key>rdbms_version</key>
	<string>5.5.52-0+deb8u1</string>
	<key>version</key>
	<integer>1</integer>
</dict>
</plist>
